import { thread } from '@cord-sdk/react';
import type { PropsWithChildren } from 'react';
import {
  useCallback,
  useEffect,
  useState,
  createContext,
  useMemo,
} from 'react';
import { LOCATION } from './components/Dashboard';

// Metadata stored on threads left on charts
export type ChartThreadMetadata = {
  type: 'chart';
  chartId: string;
  seriesId: string;
  seriesName: string;
  x: number;
  y: number;
  autogenerated?: boolean;
  resolved: boolean;
};

// Metadata stored on threads left on table grids
export type GridThreadMetadata = {
  type: 'grid';
  gridId: string;
  headerName: string;
  rowId: string;
  colId: string;
  resolved: boolean;
};

export type ThreadMetadata = ChartThreadMetadata | GridThreadMetadata;

type RequestToOpenThreadType = {
  threadID: string;
  onThreadShownCallback?: () => void;
};

// Context for storing all thread related information
type ThreadsContextType = {
  // Map of all threads on current page, mapping from thread's ID to its
  // metadata
  threads: ReadonlyMap<string, ThreadMetadata>;
  // Adds a thread to the threads map
  addThread: (threadId: string, metadata: ThreadMetadata) => void;
  // Removes a thread from the threads map
  removeThread: (threadId: string) => void;

  // The id of the thread open on this page (or null if none is open)
  openThread: string | null;
  setOpenThread: (arg: string | null) => void;

  // The id of the thread that should be open after the page makes necessary
  // adjustments to make the thread visible. Common adjustments are scrolling
  // the page, updating chart/table filters, un-collapsing the right page
  // section etc. This is useful for implementing ThreadList's onThreadClick
  // callback or for implementing URL deep-linking. If page adjustments are not
  // needed, then simply use `setOpenThread(threadId)` to open a thread.
  //
  // The standard usage pattern looks like this:
  // useEffect(() => {
  //    if (requestToOpenThread) {
  //      ...scroll the page, adjust filters, etc.
  //      setOpenThread(requestToOpenThread);
  //      setRequestToOpenThread(null);
  //   }
  // }, [requestToOpenThread, setRequestToOpenThread, setOpenThread]);
  requestToOpenThread: RequestToOpenThreadType | null;
  setRequestToOpenThread: (data: RequestToOpenThreadType | null) => void;

  allowAutofocus: boolean;
};
export const ThreadsContext = createContext<ThreadsContextType | undefined>(
  undefined,
);

export function ThreadsProvider({
  delayAutofocus = false,
  children,
}: PropsWithChildren<{ delayAutofocus?: boolean }>) {
  const [threads, setThreads] = useState<Map<string, ThreadMetadata>>(
    new Map(),
  );
  const addThread = useCallback(
    (threadId: string, metadata: ThreadMetadata) =>
      setThreads((oldThreads) => {
        const existing = oldThreads.get(threadId);
        if (existing && existing.resolved === metadata.resolved) {
          return oldThreads;
        }
        const newThreads = new Map(oldThreads);
        newThreads.set(threadId, metadata);
        return newThreads;
      }),
    [],
  );
  const removeThread = useCallback(
    (threadId: string) =>
      setThreads((oldThreads) => {
        if (!oldThreads.has(threadId)) {
          return oldThreads;
        }
        const newThreads = new Map(oldThreads);
        newThreads.delete(threadId);
        return newThreads;
      }),
    [],
  );

  // Fetch existing threads associated with location
  const {
    threads: threadSummaries,
    hasMore,
    loading,
    fetchMore,
  } = thread.useThreads({ filter: { location: LOCATION } });
  useEffect(() => {
    if (loading) {
      return;
    }
    if (hasMore) {
      // NOTE: For this demo, fetch all threads on the page.
      void fetchMore(1000);
    }
    threadSummaries
      .filter((t) => t.total > 0)
      .forEach((t) => {
        // When users mark a thread as resolved, we don't hide it until they refresh the page.
        if (t.resolved && !threads.has(t.id)) {
          return;
        }
        addThread(t.id, {
          ...t.metadata,
          resolved: t.resolved,
        } as ThreadMetadata);
      });
  }, [addThread, fetchMore, hasMore, loading, threadSummaries, threads]);

  const [openThread, setOpenThreadReal] = useState<string | null>(null);
  const [allowAutofocus, setAllowAutofocus] = useState(!delayAutofocus);
  const setOpenThread = useCallback(
    (v: string | null) => {
      if (openThread !== null && v !== openThread) {
        // Start allowing autofocus (if not already allowed) after we have
        // opened a (non-null) thread.
        setAllowAutofocus(true);
      }
      setOpenThreadReal(v);
    },
    [openThread],
  );

  const [requestToOpenThread, setRequestToOpenThread] =
    useState<RequestToOpenThreadType | null>(null);

  const context = useMemo(
    () => ({
      threads,
      addThread,
      removeThread,
      openThread,
      setOpenThread,
      requestToOpenThread,
      setRequestToOpenThread,
      allowAutofocus,
    }),
    [
      threads,
      addThread,
      removeThread,
      openThread,
      setOpenThread,
      requestToOpenThread,
      allowAutofocus,
    ],
  );
  return (
    <ThreadsContext.Provider value={context}>
      {children}
    </ThreadsContext.Provider>
  );
}
